---
layout: default
title: Exception の処理 (送出処理/捕捉処理) 
---
[Up](no1S0Auo49.html) [Top](../index.html)

#### Exception の処理 (送出処理/捕捉処理) 

--- 
## 概要(Summary)
例外処理では「ユーザーが書いた Java コード内から対応する例外ハンドラを見つけてキャッチさせる」ことが主な仕事になる.
このため処理の流れは以下の通り
(なお, 対応する例外ハンドラがなかった場合は異常終了になる).

  1. 「例外オブジェクト(java.lang.Exceptionやjava.lang.Errorのサブクラスのオブジェクト)」を作成する.

     なお, 例外オブジェクトは, HotSpot の内部的な処理中においても, Java レベルでのオブジェクト(Exception オブジェクト) の形でハンドリングされる

  2. 現在のメソッド内で対応するハンドラを見つけてジャンプする.
     現在のメソッド内で見つからなければ, スタックフレームを一つ上がって同じ処理を繰り返す.

このうち, "2." の例外ハンドラの探索処理では以下のように処理が行われる.
どちらの場合も, 対応するハンドラが見つかるまでスタックフレームの unwind が繰り返される.

  * Java コード内の場合:

    例外ハンドラテーブル情報がクラスファイルに埋め込まれているため, それを用いる.

    現在のスタックフレームに対応するメソッドのテーブルを調べ, 
    該当する例外ハンドラが見つかればそこにジャンプする.
    見つからなければスタックフレームの unwind を行い, 見つかるまで同じことを繰り返す.

  * それ以外の場合 (= ネイティブコード内(JVM 内部や JNI コード内)の場合):

    ネイティブコードには例外ハンドラテーブル情報といったものはない.
    代わりに, もしネイティブコード内でその例外に対する捕捉処理 (ExceptionClear()) が行われれば, そこで例外は消滅する (See: [here](nok1NPdCrM.html) for details).

    例外が捕捉されなければフレームを unwind することになるが,
    ネイティブコードのスタックを (C++の例外機能等を用いて) unwind すると処理がコンパイラ依存になったり性能が予見できなくなる恐れがある.
    このため, 明示的な return で unwind 処理を行うことになっている.



## Subcategories
* [(#TBD) Exception の処理 ： 関連するクラス／データ構造](noTA5Fwk10.html)
* [Exception の処理 ： 処理の概要](nogMJcsk14.html)
* [Exception の処理 ： 処理の詳細 (1) ： 例外送出条件の検出処理](noGGgR6UDC.html)
* [Exception の処理 ： 処理の詳細 (2)~(3) ： 例外オブジェクトの生成処理 ~ 例外の送出処理](noHNONT0aT.html)
* [Exception の処理 ： 処理の詳細 (4) ： 例外ハンドラの探索処理](noAJsAY6Zl.html)
* [Exception の処理 ： その他](noZknaL7f-.html)



