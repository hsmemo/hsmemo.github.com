---
layout: default
title: AccessFlags クラス 
---
[Top](../index.html)

#### AccessFlags クラス 



---
## <a name="noOQLCOUeF" id="noOQLCOUeF">AccessFlags</a>

### 概要(Summary)
クラスやメソッドの「アクセスフラグ」情報を表すためのユーティリティ・クラス.
1つの AccessFlags オブジェクトが 1つの「アクセスフラグ」情報に対応する.

(なおアクセスフラグ(access flag)とは, "public" や "synchronized" といった情報を表現するビットマップのこと).


```cpp
    ((cite: hotspot/src/share/vm/utilities/accessFlags.hpp))
    // AccessFlags is an abstraction over Java access flags.
```


```cpp
    ((cite: hotspot/src/share/vm/utilities/accessFlags.hpp))
    class AccessFlags VALUE_OBJ_CLASS_SPEC {
```

### 内部構造(Internal structure)
アクセスフラグのうち, JVM 標準のフラグについては jvm.h で定義されている.


```cpp
    ((cite: hotspot/src/share/vm/prims/jvm.h))
    #define JVM_ACC_PUBLIC        0x0001  /* visible to everyone */
    #define JVM_ACC_PRIVATE       0x0002  /* visible only to the defining class */
    #define JVM_ACC_PROTECTED     0x0004  /* visible to subclasses */
    #define JVM_ACC_STATIC        0x0008  /* instance variable is static */
    #define JVM_ACC_FINAL         0x0010  /* no further subclassing, overriding */
    #define JVM_ACC_SYNCHRONIZED  0x0020  /* wrap method call in monitor lock */
    #define JVM_ACC_SUPER         0x0020  /* funky handling of invokespecial */
    #define JVM_ACC_VOLATILE      0x0040  /* can not cache in registers */
    #define JVM_ACC_BRIDGE        0x0040  /* bridge method generated by compiler */
    #define JVM_ACC_TRANSIENT     0x0080  /* not persistent */
    #define JVM_ACC_VARARGS       0x0080  /* method declared with variable number of args */
    #define JVM_ACC_NATIVE        0x0100  /* implemented in C */
    #define JVM_ACC_INTERFACE     0x0200  /* class is an interface */
    #define JVM_ACC_ABSTRACT      0x0400  /* no definition provided */
    #define JVM_ACC_STRICT        0x0800  /* strict floating point */
    #define JVM_ACC_SYNTHETIC     0x1000  /* compiler-generated class, method or field */
    #define JVM_ACC_ANNOTATION    0x2000  /* annotation type */
    #define JVM_ACC_ENUM          0x4000  /* field is declared as element of enum */
```

代わりに, このクラスでは HotSpot に特有なフラグの定義が行われている.


```cpp
    ((cite: hotspot/src/share/vm/utilities/accessFlags.hpp))
      // See jvm.h for shared JVM_ACC_XXX access flags
    
      // HotSpot-specific access flags
    
      // flags actually put in .class file
      JVM_ACC_WRITTEN_FLAGS           = 0x00007FFF,
    
      // methodOop flags
      JVM_ACC_MONITOR_MATCH           = 0x10000000,     // True if we know that monitorenter/monitorexit bytecodes match
      JVM_ACC_HAS_MONITOR_BYTECODES   = 0x20000000,     // Method contains monitorenter/monitorexit bytecodes
      JVM_ACC_HAS_LOOPS               = 0x40000000,     // Method has loops
      JVM_ACC_LOOPS_FLAG_INIT         = (int)0x80000000,// The loop flag has been initialized
      JVM_ACC_QUEUED                  = 0x01000000,     // Queued for compilation
      JVM_ACC_NOT_C2_COMPILABLE       = 0x02000000,
      JVM_ACC_NOT_C1_COMPILABLE       = 0x04000000,
      JVM_ACC_NOT_OSR_COMPILABLE      = 0x08000000,
      JVM_ACC_HAS_LINE_NUMBER_TABLE   = 0x00100000,
      JVM_ACC_HAS_CHECKED_EXCEPTIONS  = 0x00400000,
      JVM_ACC_HAS_JSRS                = 0x00800000,
      JVM_ACC_IS_OLD                  = 0x00010000,     // RedefineClasses() has replaced this method
      JVM_ACC_IS_OBSOLETE             = 0x00020000,     // RedefineClasses() has made method obsolete
      JVM_ACC_IS_PREFIXED_NATIVE      = 0x00040000,     // JVMTI has prefixed this native method
    
      JVM_MH_INVOKE_BITS           // = 0x10001100      // MethodHandle.invoke quasi-native
                                      = (JVM_ACC_NATIVE | JVM_ACC_SYNTHETIC | JVM_ACC_MONITOR_MATCH),
    
      // klassOop flags
      JVM_ACC_HAS_MIRANDA_METHODS     = 0x10000000,     // True if this class has miranda methods in it's vtable
      JVM_ACC_HAS_VANILLA_CONSTRUCTOR = 0x20000000,     // True if klass has a vanilla default constructor
      JVM_ACC_HAS_FINALIZER           = 0x40000000,     // True if klass has a non-empty finalize() method
      JVM_ACC_IS_CLONEABLE            = (int)0x80000000,// True if klass supports the Clonable interface
      JVM_ACC_HAS_FINAL_METHOD        = 0x01000000,     // True if klass has final method
    
      // klassOop and methodOop flags
      JVM_ACC_HAS_LOCAL_VARIABLE_TABLE= 0x00200000,
    
      JVM_ACC_PROMOTED_FLAGS          = 0x00200000,     // flags promoted from methods to the holding klass
    
      // field flags
      // Note: these flags must be defined in the low order 16 bits because
      // instanceKlass only stores a ushort worth of information from the
      // AccessFlags value.
      // These bits must not conflict with any other field-related access flags
      // (e.g., ACC_ENUM).
      // Note that the class-related ACC_ANNOTATION bit conflicts with these flags.
      JVM_ACC_FIELD_ACCESS_WATCHED       = 0x00002000,  // field access is watched by JVMTI
      JVM_ACC_FIELD_MODIFICATION_WATCHED = 0x00008000,  // field modification is watched by JVMTI
    
                                                        // flags accepted by set_field_flags()
      JVM_ACC_FIELD_FLAGS                = 0x00008000 | JVM_ACC_WRITTEN_FLAGS
```

また, 各フラグがたっているかどうかを調べるためのメソッドも提供している

(このメソッドについては標準的なフラグ用のものも含めて提供されている)


```cpp
    ((cite: hotspot/src/share/vm/utilities/accessFlags.hpp))
      // Java access flags
      bool is_public      () const         { return (_flags & JVM_ACC_PUBLIC      ) != 0; }
      bool is_private     () const         { return (_flags & JVM_ACC_PRIVATE     ) != 0; }
      bool is_protected   () const         { return (_flags & JVM_ACC_PROTECTED   ) != 0; }
      bool is_static      () const         { return (_flags & JVM_ACC_STATIC      ) != 0; }
      bool is_final       () const         { return (_flags & JVM_ACC_FINAL       ) != 0; }
      bool is_synchronized() const         { return (_flags & JVM_ACC_SYNCHRONIZED) != 0; }
      bool is_super       () const         { return (_flags & JVM_ACC_SUPER       ) != 0; }
      bool is_volatile    () const         { return (_flags & JVM_ACC_VOLATILE    ) != 0; }
      bool is_transient   () const         { return (_flags & JVM_ACC_TRANSIENT   ) != 0; }
      bool is_native      () const         { return (_flags & JVM_ACC_NATIVE      ) != 0; }
      bool is_interface   () const         { return (_flags & JVM_ACC_INTERFACE   ) != 0; }
      bool is_abstract    () const         { return (_flags & JVM_ACC_ABSTRACT    ) != 0; }
      bool is_strict      () const         { return (_flags & JVM_ACC_STRICT      ) != 0; }
    
      // Attribute flags
      bool is_synthetic   () const         { return (_flags & JVM_ACC_SYNTHETIC   ) != 0; }
    
      // methodOop flags
      bool is_monitor_matching     () const { return (_flags & JVM_ACC_MONITOR_MATCH          ) != 0; }
      bool has_monitor_bytecodes   () const { return (_flags & JVM_ACC_HAS_MONITOR_BYTECODES  ) != 0; }
      bool has_loops               () const { return (_flags & JVM_ACC_HAS_LOOPS              ) != 0; }
      bool loops_flag_init         () const { return (_flags & JVM_ACC_LOOPS_FLAG_INIT        ) != 0; }
      bool queued_for_compilation  () const { return (_flags & JVM_ACC_QUEUED                 ) != 0; }
      bool is_not_c1_compilable () const    { return (_flags & JVM_ACC_NOT_C1_COMPILABLE      ) != 0; }
      bool is_not_c2_compilable () const    { return (_flags & JVM_ACC_NOT_C2_COMPILABLE      ) != 0; }
      bool is_not_osr_compilable   () const { return (_flags & JVM_ACC_NOT_OSR_COMPILABLE     ) != 0; }
      bool has_linenumber_table    () const { return (_flags & JVM_ACC_HAS_LINE_NUMBER_TABLE  ) != 0; }
      bool has_checked_exceptions  () const { return (_flags & JVM_ACC_HAS_CHECKED_EXCEPTIONS ) != 0; }
      bool has_jsrs                () const { return (_flags & JVM_ACC_HAS_JSRS               ) != 0; }
      bool is_old                  () const { return (_flags & JVM_ACC_IS_OLD                 ) != 0; }
      bool is_obsolete             () const { return (_flags & JVM_ACC_IS_OBSOLETE            ) != 0; }
      bool is_prefixed_native      () const { return (_flags & JVM_ACC_IS_PREFIXED_NATIVE     ) != 0; }
    
      // JSR 292:  A method of the form MethodHandle.invoke(A...)R method is
      // neither bytecoded nor a JNI native, but rather a fast call through
      // a lightweight method handle object.  Because it is not bytecoded,
      // it has the native bit set, but the monitor-match bit is also set
      // to distinguish it from a JNI native (which never has the match bit set).
      // The synthetic bit is also present, because such a method is never
      // explicitly defined in Java code.
      bool is_method_handle_invoke () const { return (_flags & JVM_MH_INVOKE_BITS) == JVM_MH_INVOKE_BITS; }
    
      // klassOop flags
      bool has_miranda_methods     () const { return (_flags & JVM_ACC_HAS_MIRANDA_METHODS    ) != 0; }
      bool has_vanilla_constructor () const { return (_flags & JVM_ACC_HAS_VANILLA_CONSTRUCTOR) != 0; }
      bool has_finalizer           () const { return (_flags & JVM_ACC_HAS_FINALIZER          ) != 0; }
      bool has_final_method        () const { return (_flags & JVM_ACC_HAS_FINAL_METHOD       ) != 0; }
    ...
```

その他に, アクセスフラグ情報を変更する (ビットマップ中のビットを立てたり消したりする) ためのメソッドも提供されている.


```cpp
    ((cite: hotspot/src/share/vm/utilities/accessFlags.hpp))
      // Atomic update of flags
      void atomic_set_bits(jint bits);
      void atomic_clear_bits(jint bits);
```




### 詳細(Details)
See: [here](../doxygen/classAccessFlags.html) for details

---
